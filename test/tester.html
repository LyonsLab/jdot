<html>
<body>

<div>
    Number of points: <input id='num_points' size='15'>
    <button onclick='setPoints();'>Run</button><br>
    <!--Type: <button id='type' onclick='toggleType();'>Points</button> -->
</div>

<div>
	<canvas id="view">Oops ... your web browser does not support HTML5!</canvas>
	<canvas id="xaxis"></canvas>
	<canvas id="yaxis"></canvas>
</div>

<script src="../src/dotplot2.js"></script>
<script src="../src/quadtree.js"></script>
<script>
var initData = init_array;
var fetchData = fetch_array;

var gu1 = 2*1000*1000;
var gu2 = 3*1000*1000;
var chromosomes1 = [ 
    { name: '1', length: 100000 },
    { name: '2', length: 200000 },
    { name: '3', length: 300000 },
    { name: '4', length: 1400000 }
];
var chromosomes2 = [ 
    { name: 'a', length: 200000 },
    { name: 'b', length: 250000 },
    { name: 'c', length: 350000 },
    { name: 'd', length: 2200000 }
];

var maxTiles = 100;
var tileColSize = Math.floor(gu1/maxTiles);
var tileRowSize = Math.floor(gu2/maxTiles);

var view = document.getElementById('view');
var xaxis = document.getElementById('xaxis');
var yaxis = document.getElementById('yaxis');

var dp = new DotPlot(view, 
	chromosomes1, chromosomes2, 
	{   size: { width: 1000, height: 800 }, 
	    extent: { width: gu1, height: gu2 },
	    style: {
	    	left: "50px",
	    	top: "100px",
	    	position: "absolute"
	    }
	}
);
dp.setFetch(fetchData);

var xrule = new Rule(
	xaxis, 
	{   size: { width: 1000, height: 50 }, 
	    extent: gu1, 
		orientation: 'horizontal',
		labels: chromosomes1,
		style: {
			left: "50px",
			top: "50px",
			position: "absolute"
		}
    }
);
xrule.draw();

var yrule = new Rule(
    yaxis, 
    {   size: { width: 50, height: 800 }, 
        extent: gu2, 
        orientation: 'vertical',
        labels: chromosomes2,
        style: {
        	left: "0px",
        	top: "100px",
        	position: "absolute"
        }
    }
);
yrule.draw();

//var qt = QuadTree(gu1, gu2);

var data;
var tiles;
setPoints(100*1000);

view.onmousewheel = onmousewheel;
view.onmousedown  = onmousedown;
view.onmouseup    = onmouseup;
view.onmousemove  = onmousemove;

xaxis.onmousewheel = onmousewheel;
xaxis.onmousedown  = onmousedown;
xaxis.onmouseup    = onmouseup;
xaxis.onmousemove  = onmousemove;
//xaxis.onclick      = onclick;

yaxis.onmousewheel = onmousewheel;
yaxis.onmousedown  = onmousedown;
yaxis.onmouseup    = onmouseup;
yaxis.onmousemove  = onmousemove;

document.onmousedown = onmousedown;
document.onmouseup   = onmouseup;
document.onmousemove = onmousemove;

var mouseTarget;
	
//------------------------------------------------------------------------------
function onmousewheel(e) {
    var axis;
    if (e.target.id == 'xaxis') {
        axis = 'x';
        xrule.onmousewheel(e);
    }
    else if (e.target.id == 'yaxis') {
        axis = 'y';
        yrule.onmousewheel(e);
    }
    else {
    	xrule.onmousewheel(e);
    	yrule.onmousewheel(e);
    }
    dp.onmousewheel(e, axis);
}

function onmousemove(e) {
    if (mouseTarget) {
    	console.log('onmousemove target='+mouseTarget.id);
/*         if (e.target != mouseTarget) {
            console.log('mousemove mismatch');
            return;
        } */
    }
	if (mouseTarget && e.shiftKey) {
	    if (mouseTarget.id == 'xaxis' && xrule.mouse.isDown) {
	    	var x1 = e.clientX - xrule.element.offsetLeft;
            var y1 = e.clientY - xrule.element.offsetTop;
            var x2 = xrule.mouse.drag.offset.x - xrule.element.offsetLeft;
            var y2 = xrule.mouse.drag.offset.y - xrule.element.offsetTop;
            xrule.highlight(x1, y1, x2, y2);
	    }
	    else if (mouseTarget.id == 'yaxis' && yrule.mouse.isDown) {
	        var x1 = e.clientX - yrule.element.offsetLeft;
	        var y1 = e.clientY - yrule.element.offsetTop;
	        var x2 = yrule.mouse.drag.offset.x - yrule.element.offsetLeft;
	        var y2 = yrule.mouse.drag.offset.y - yrule.element.offsetTop;
            yrule.highlight(x1, y1, x2, y2);
	    }
	    else if (mouseTarget.id == 'view' && dp.mouse.isDown) {
            var x1 = e.clientX - dp.element.offsetLeft;
            var y1 = e.clientY - dp.element.offsetTop;
            var x2 = dp.mouse.drag.offset.x - dp.element.offsetLeft;
            var y2 = dp.mouse.drag.offset.y - dp.element.offsetTop;
    		dp.highlight(x1, y1, x2, y2);
	    }
	}
	else {
		var axis;
		if (e.target.id == 'xaxis') {
			axis = 'x';
			xrule.onmousemove(e);
			dp.onmousemove(e, axis);
		}
		else if (e.target.id == 'yaxis') {
            axis = 'y';
            yrule.onmousemove(e);
            dp.onmousemove(e, axis);
        }
		else if (e.target.id == 'view') {
		    xrule.onmousemove(e);
		    yrule.onmousemove(e);
		    dp.onmousemove(e);
		}
	}
}

function onmousedown(e) {
	if (mouseTarget) {
		console.log('onmousedown target='+mouseTarget.id);
		if (e.target != mouseTarget) {
			console.log('mousedown mismatch');
			return;
		}
	}
	mouseTarget = e.target;
	if (e.target.id == 'xaxis') {
		xrule.onmousedown(e);
		dp.onmousedown(e);
	}
	else if (e.target.id == 'yaxis') {
		yrule.onmousedown(e);
		dp.onmousedown(e);
	}
	else if (e.target.id == 'view') {
		xrule.onmousedown(e);
		yrule.onmousedown(e);
	    dp.onmousedown(e);
	}
}

function onmouseup(e) {
    if (mouseTarget) {
    	console.log('onmouseup target='+mouseTarget.id);
        /* if (e.target != mouseTarget) {
            console.log('mousemove mismatch');
            return;
        } */
    }
	if (mouseTarget && e.shiftKey) { // FIXME: optimize please ... are abs/min checks still necessary?
		if (mouseTarget.id == 'xaxis' && xrule.mouse.isDown) {
			var x1 = e.clientX - xrule.element.offsetLeft;
            var y1 = e.clientY - xrule.element.offsetTop;
            var x2 = xrule.mouse.drag.offset.x - xrule.element.offsetLeft;
            var y2 = xrule.mouse.drag.offset.y - xrule.element.offsetTop;
            xrule.select(x1, y1, x2, y2);
            dp.select(x1, 0, x2, dp.element.height);
		}
		else if (mouseTarget.id == 'yaxis' && yrule.mouse.isDown) {
			var x1 = e.clientX - yrule.element.offsetLeft;
            var y1 = e.clientY - yrule.element.offsetTop;
            var x2 = yrule.mouse.drag.offset.x - yrule.element.offsetLeft;
            var y2 = yrule.mouse.drag.offset.y - yrule.element.offsetTop;
            yrule.select(x1, y1, x2, y2);
            dp.select(0, y1, dp.element.width, y2);
	    }
		else if (mouseTarget.id == 'view' && dp.mouse.isDown) {
			var x1 = e.clientX - dp.element.offsetLeft;
			var y1 = e.clientY - dp.element.offsetTop;
            var x2 = dp.mouse.drag.offset.x - dp.element.offsetLeft;
            var y2 = dp.mouse.drag.offset.y - dp.element.offsetTop;
            xrule.select(x1, y1, x2, y2);
            yrule.select(x1, y1, x2, y2);
    		dp.select(x1, y1, x2, y2);
		}
	}
    dp.onmouseup(e);
    xrule.onmouseup(e);
    yrule.onmouseup(e);
    
    mouseTarget = null;
}

/* function onclick(e) {
	
} */

/* function init_qt(n) {
	console.log('init_qt ' + n);
    qt.clear();
    data = [];
    
    // Generate some random data points
    for (var i=0; i < n; i++) {
        var x = Math.floor( Math.random() * gu1 );//dp.config.size.width;
        var y = Math.floor( Math.random() * gu2 );//dp.config.size.height;
        data.push({ x: x, y: y, dataType: 'point' });
    }
    
    qt.insert(data);
}

function fetch_qt(x, y, width, height) {
    var subset = qt.query_with_density( new rectangle(x, y, width, height), 500, 500);//qt.query_with_density
    console.log('fetch: ' + subset.length + ' ' + x + ' ' + y + ' ' + width + ' '  + height);
    //console.log(subset);
    return subset;
} */

function init_array(n) {
    // Generate some random data points
    data = [];
    for (var i=0; i < n; i++) {
        var x = Math.floor( Math.random() * gu1 );
        var y = Math.floor( Math.random() * gu2 );
        data.push({ x: x, y: y, dataType: 'point' });
    }
}

function fetch_array(x, y, width, height) {
    return data;
}

function init_tiles(n) {
    // Generate some random data points
    tiles = [];
    for (var i=0; i < n; i++) {
        var x = Math.floor( Math.random() * gu1 );
        var y = Math.floor( Math.random() * gu2 );
        var col = Math.floor(x/tileColSize);
        var row = Math.floor(y/tileRowSize);
        var t = row * maxTiles + col;
        if (!tiles[t])
        	tiles[t] = [];
        tiles[t].push({ x: x, y: y});
    }
}

function fetch_tiles(x, y, width, height) {
	var col1 = int(x/tileColSize);
	var row1 = int(y/tileRowSize);
	var col2 = col1 + Math.ceil(width/tileColSize);
	var row2 = row1 + Math.ceil(height/tileRowSize);
	var data = [];
	for (var r = row1; r <= row2; r++) {
		for (var c = col1; c <= col2; c++) {
			var t = r * maxTiles + c;
            if (tiles[t]) {
            	for (var i = 0; i < tiles[t].length; i++)
            	    data.push(tiles[t][i]);
            }
		}
	}
    return data;
}

function setPoints(n) {
	if (n) 
		document.getElementById('num_points').value = n;
	else
		n = document.getElementById('num_points').value;
	
	initData(n);
	dp.redraw();
}

function toggleType() {
    document.getElementById('type').innerHTML = 'Points';
    dp.redraw();
}

document.onkeydown = function(e) {
	console.log('keydown');
    switch(e.keyCode) {
        case 37: dp.translate( 5,  0 ); break; // left
        case 38: dp.translate( 0,  5 ); break; // up
        case 39: dp.translate( -5, 0 ); break; // right
        case 40: dp.translate( 0, -5 ); break; // down
    }
    
    dp.redraw();
};

</script>

</body>
</html>


